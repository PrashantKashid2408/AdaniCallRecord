'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var jwtDecode = _interopDefault(require('jwt-decode'));
var coreHttp = require('@azure/core-http');
var crypto = require('crypto');
var coreAuth = require('@azure/core-auth');
var tslib = require('tslib');

// Copyright (c) Microsoft Corporation.
const parseToken = (token) => {
    const { exp } = jwtDecode(token);
    return {
        token,
        expiresOnTimestamp: exp * 1000
    };
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * StaticTokenCredential
 */
class StaticTokenCredential {
    constructor(token) {
        this.token = token;
    }
    async getToken() {
        return this.token;
    }
    dispose() {
        /* intentionally empty */
    }
}

// Copyright (c) Microsoft Corporation.
const expiredToken = { token: "", expiresOnTimestamp: -10 };
const minutesToMs = (minutes) => minutes * 1000 * 60;
const defaultRefreshingInterval = minutesToMs(10);
class AutoRefreshTokenCredential {
    constructor(refreshArgs) {
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? parseToken(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async getToken(options) {
        if (!this.isCurrentTokenExpiringSoon) {
            return this.currentToken;
        }
        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
        if (!this.isCurrentTokenValid) {
            await updatePromise;
        }
        return this.currentToken;
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
    }
    async updateTokenAndReschedule(abortSignal) {
        if (this.activeTokenUpdating) {
            return this.activeTokenUpdating;
        }
        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
        try {
            await this.activeTokenUpdating;
        }
        finally {
            this.activeTokenUpdating = null;
        }
    }
    async refreshTokenAndReschedule(abortSignal) {
        this.currentToken = await this.refreshToken(abortSignal);
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async refreshToken(abortSignal) {
        try {
            if (!this.activeTokenFetching) {
                this.activeTokenFetching = this.refresh(abortSignal);
            }
            return parseToken(await this.activeTokenFetching);
        }
        finally {
            this.activeTokenFetching = null;
        }
    }
    scheduleRefresh() {
        if (this.disposed) {
            return;
        }
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
    }
    get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
    }
    get isCurrentTokenExpiringSoon() {
        return (!this.currentToken ||
            Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The CommunicationTokenCredential implementation with support for proactive token refresh.
 */
class AzureCommunicationTokenCredential {
    constructor(tokenOrRefreshOptions) {
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") {
            this.tokenCredential = new StaticTokenCredential(parseToken(tokenOrRefreshOptions));
        }
        else {
            this.tokenCredential = new AutoRefreshTokenCredential(tokenOrRefreshOptions);
        }
    }
    /**
     * Gets an `AccessToken` for the user. Throws if already disposed.
     * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
     */
    async getToken(options) {
        this.throwIfDisposed();
        const token = await this.tokenCredential.getToken(options);
        this.throwIfDisposed();
        return token;
    }
    /**
     * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
     */
    dispose() {
        this.disposed = true;
        this.tokenCredential.dispose();
    }
    throwIfDisposed() {
        if (this.disposed) {
            throw new Error("User credential is disposed");
        }
    }
}

// Copyright (c) Microsoft Corporation.
const shaHash = async (content) => crypto.createHash("sha256")
    .update(content)
    .digest("base64");
const shaHMAC = async (secret, content) => {
    const decodedSecret = Buffer.from(secret, "base64");
    return crypto.createHmac("sha256", decodedSecret)
        .update(content)
        .digest("base64");
};

// Copyright (c) Microsoft Corporation.
/**
 * Creates an HTTP pipeline policy to authenticate a request using a `KeyCredential`.
 * @hidden
 *
 * @param credential - The key credential.
 */
const createCommunicationAccessKeyCredentialPolicy = (credential) => {
    return {
        create: (nextpolicy, options) => {
            return new CommunicationAccessKeyCredentialPolicy(credential, nextpolicy, options);
        }
    };
};
/**
 * CommunicationAccessKeyCredentialPolicy provides a means of signing requests made through
 * the SmsClient.
 */
class CommunicationAccessKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    /**
     * Initializes a new instance of the CommunicationAccessKeyCredential class
     * using a base64 encoded key.
     * @param accessKey - The base64 encoded key to be used for signing.
     */
    constructor(accessKey, nextPolicy, options) {
        super(nextPolicy, options);
        this.accessKey = accessKey;
    }
    /**
     * Signs a request with the provided access key.
     *
     * @param webResource - The WebResource to be signed.
     */
    async signRequest(webResource) {
        const verb = webResource.method.toUpperCase();
        const utcNow = new Date().toUTCString();
        const contentHash = await shaHash(webResource.body || "");
        const dateHeader = "x-ms-date";
        const signedHeaders = `${dateHeader};host;x-ms-content-sha256`;
        const url = coreHttp.URLBuilder.parse(webResource.url);
        const query = url.getQuery();
        const urlPathAndQuery = query ? `${url.getPath()}?${query}` : url.getPath();
        const port = url.getPort();
        const hostAndPort = port ? `${url.getHost()}:${port}` : url.getHost();
        const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${hostAndPort};${contentHash}`;
        const signature = await shaHMAC(this.accessKey.key, stringToSign);
        {
            webResource.headers.set("Host", hostAndPort || "");
        }
        webResource.headers.set(dateHeader, utcNow);
        webResource.headers.set("x-ms-content-sha256", contentHash);
        webResource.headers.set("Authorization", `HMAC-SHA256 SignedHeaders=${signedHeaders}&Signature=${signature}`);
        return webResource;
    }
    /**
     * Signs the request and calls the next policy in the factory.
     */
    async sendRequest(webResource) {
        if (!webResource) {
            throw new Error("webResource cannot be null or undefined");
        }
        return this._nextPolicy.sendRequest(await this.signRequest(webResource));
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a pipeline policy to authenticate request based
 * on the credential passed in.
 * @hidden
 *
 * @param credential - The KeyCredential or TokenCredential.
 */
const createCommunicationAuthPolicy = (credential) => {
    if (coreAuth.isTokenCredential(credential)) {
        return coreHttp.bearerTokenAuthenticationPolicy(credential, "https://communication.azure.com//.default");
    }
    else {
        return createCommunicationAccessKeyCredentialPolicy(credential);
    }
};

// Copyright (c) Microsoft Corporation.
// TODO: update when connection string format is finalized
const CONNECTION_STRING_REGEX = /endpoint=(.*);accesskey=(.*)/i;
const tryParseConnectionString = (s) => {
    const match = s.match(CONNECTION_STRING_REGEX);
    if ((match === null || match === void 0 ? void 0 : match[1]) && match[2]) {
        return { endpoint: match[1], credential: new coreAuth.AzureKeyCredential(match[2]) };
    }
    return undefined;
};
/**
 * Returns an EndpointCredential to easily access properties of the connection string.
 * @hidden
 *
 * @param connectionString - The connection string to parse
 * @returns Object to access the endpoint and the credenials
 */
const parseConnectionString = (connectionString) => {
    const parsedConnectionString = tryParseConnectionString(connectionString);
    if (parsedConnectionString) {
        return parsedConnectionString;
    }
    else {
        throw new Error(`Invalid connection string ${connectionString}`);
    }
};

// Copyright (c) Microsoft Corporation.
const isValidEndpoint = (host) => {
    var _a;
    const url = coreHttp.URLBuilder.parse(host);
    return (!!((_a = url.getScheme()) === null || _a === void 0 ? void 0 : _a.match(/^http[s]?/)) &&
        url.getHost() !== undefined &&
        url.getHost() !== "" &&
        (url.getPath() === undefined || url.getPath() === "" || url.getPath() === "/"));
};
const assertValidEndpoint = (host) => {
    if (!isValidEndpoint(host)) {
        throw new Error(`Invalid endpoint url ${host}`);
    }
};
/**
 * Checks whether a value is a KeyCredential.
 *
 * @param credential - The credential being checked.
 */
const isKeyCredential = (credential) => {
    const castCredential = credential;
    return (castCredential &&
        typeof castCredential.key === "string" &&
        castCredential.getToken === undefined);
};
/**
 * Parses arguments passed to a communication client.
 * @hidden
 */
const parseClientArguments = (connectionStringOrUrl, credentialOrOptions) => {
    if (isKeyCredential(credentialOrOptions) || coreAuth.isTokenCredential(credentialOrOptions)) {
        assertValidEndpoint(connectionStringOrUrl);
        return { url: connectionStringOrUrl, credential: credentialOrOptions };
    }
    else {
        const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);
        assertValidEndpoint(host);
        return { url: host, credential };
    }
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.
 *
 * @param identifier - The assumed CommunicationUserIdentifier to be tested.
 */
const isCommunicationUserIdentifier = (identifier) => {
    return typeof identifier.communicationUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements PhoneNumberIdentifier.
 *
 * @param identifier - The assumed PhoneNumberIdentifier to be tested.
 */
const isPhoneNumberIdentifier = (identifier) => {
    return typeof identifier.phoneNumber === "string";
};
/**
 * Tests an Identifier to determine whether it implements MicrosoftTeamsUserIdentifier.
 *
 * @param identifier - The assumed available to be tested.
 */
const isMicrosoftTeamsUserIdentifier = (identifier) => {
    return typeof identifier.microsoftTeamsUserId === "string";
};
/**
 * Tests an Identifier to determine whether it implements UnknownIdentifier.
 *
 * @param identifier - The assumed UnknownIdentifier to be tested.
 */
const isUnknownIdentifier = (identifier) => {
    return typeof identifier.id === "string";
};
/**
 * Returns the CommunicationIdentifierKind for a given CommunicationIdentifier. Returns undefined if the kind couldn't be inferred.
 *
 * @param identifier - The identifier whose kind is to be inferred.
 */
const getIdentifierKind = (identifier) => {
    if (isCommunicationUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "communicationUser" });
    }
    if (isPhoneNumberIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "phoneNumber" });
    }
    if (isMicrosoftTeamsUserIdentifier(identifier)) {
        return Object.assign(Object.assign({}, identifier), { kind: "microsoftTeamsUser" });
    }
    return Object.assign(Object.assign({}, identifier), { kind: "unknown" });
};

// Copyright (c) Microsoft Corporation.
const addRawIdIfExisting = (identifier, rawId) => {
    return rawId === undefined ? identifier : Object.assign(Object.assign({}, identifier), { rawId: rawId });
};
const assertNotNullOrUndefined = (obj, prop) => {
    const subObjName = Object.keys(obj)[0];
    const subObj = obj[subObjName];
    if (prop in subObj) {
        return subObj[prop];
    }
    throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
};
const assertMaximumOneNestedModel = (identifier) => {
    const props = tslib.__rest(identifier, ["rawId"]);
    const keys = Object.keys(props);
    if (keys.length > 1) {
        throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);
    }
};
/**
 * @hidden
 * Translates a CommunicationIdentifier to its serialized format for sending a request.
 * @param identifier - The CommunicationIdentifier to be serialized.
 */
const serializeCommunicationIdentifier = (identifier) => {
    var _a, _b;
    const identifierKind = getIdentifierKind(identifier);
    switch (identifierKind.kind) {
        case "communicationUser":
            return { communicationUser: { id: identifierKind.communicationUserId } };
        case "phoneNumber":
            return addRawIdIfExisting({ phoneNumber: { value: identifierKind.phoneNumber } }, identifierKind.rawId);
        case "microsoftTeamsUser":
            return addRawIdIfExisting({
                microsoftTeamsUser: {
                    userId: identifierKind.microsoftTeamsUserId,
                    isAnonymous: (_a = identifierKind.isAnonymous) !== null && _a !== void 0 ? _a : false,
                    cloud: (_b = identifierKind.cloud) !== null && _b !== void 0 ? _b : "public"
                }
            }, identifierKind.rawId);
        case "unknown":
            return { rawId: identifierKind.id };
        default:
            throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
    }
};
/**
 * @hidden
 * Translates the serialized format of a communication identifier to CommunicationIdentifier.
 * @param serializedIdentifier - The SerializedCommunicationIdentifier to be deserialized.
 */
const deserializeCommunicationIdentifier = (serializedIdentifier) => {
    assertMaximumOneNestedModel(serializedIdentifier);
    const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
    if (communicationUser) {
        return {
            kind: "communicationUser",
            communicationUserId: assertNotNullOrUndefined({ communicationUser }, "id")
        };
    }
    if (phoneNumber) {
        return {
            kind: "phoneNumber",
            phoneNumber: assertNotNullOrUndefined({ phoneNumber }, "value"),
            rawId: assertNotNullOrUndefined({ phoneNumber: serializedIdentifier }, "rawId")
        };
    }
    if (microsoftTeamsUser) {
        return {
            kind: "microsoftTeamsUser",
            microsoftTeamsUserId: assertNotNullOrUndefined({ microsoftTeamsUser }, "userId"),
            isAnonymous: assertNotNullOrUndefined({ microsoftTeamsUser }, "isAnonymous"),
            cloud: assertNotNullOrUndefined({ microsoftTeamsUser }, "cloud"),
            rawId: assertNotNullOrUndefined({ microsoftTeamsUser: serializedIdentifier }, "rawId")
        };
    }
    return {
        kind: "unknown",
        id: assertNotNullOrUndefined({ unknown: serializedIdentifier }, "rawId")
    };
};

exports.AzureCommunicationTokenCredential = AzureCommunicationTokenCredential;
exports.createCommunicationAccessKeyCredentialPolicy = createCommunicationAccessKeyCredentialPolicy;
exports.createCommunicationAuthPolicy = createCommunicationAuthPolicy;
exports.deserializeCommunicationIdentifier = deserializeCommunicationIdentifier;
exports.getIdentifierKind = getIdentifierKind;
exports.isCommunicationUserIdentifier = isCommunicationUserIdentifier;
exports.isKeyCredential = isKeyCredential;
exports.isMicrosoftTeamsUserIdentifier = isMicrosoftTeamsUserIdentifier;
exports.isPhoneNumberIdentifier = isPhoneNumberIdentifier;
exports.isUnknownIdentifier = isUnknownIdentifier;
exports.parseClientArguments = parseClientArguments;
exports.parseConnectionString = parseConnectionString;
exports.serializeCommunicationIdentifier = serializeCommunicationIdentifier;
//# sourceMappingURL=index.js.map
