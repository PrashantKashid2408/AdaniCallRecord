// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { parseToken } from "./tokenParser";
const expiredToken = { token: "", expiresOnTimestamp: -10 };
const minutesToMs = (minutes) => minutes * 1000 * 60;
const defaultRefreshingInterval = minutesToMs(10);
export class AutoRefreshTokenCredential {
    constructor(refreshArgs) {
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? parseToken(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async getToken(options) {
        if (!this.isCurrentTokenExpiringSoon) {
            return this.currentToken;
        }
        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
        if (!this.isCurrentTokenValid) {
            await updatePromise;
        }
        return this.currentToken;
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
    }
    async updateTokenAndReschedule(abortSignal) {
        if (this.activeTokenUpdating) {
            return this.activeTokenUpdating;
        }
        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
        try {
            await this.activeTokenUpdating;
        }
        finally {
            this.activeTokenUpdating = null;
        }
    }
    async refreshTokenAndReschedule(abortSignal) {
        this.currentToken = await this.refreshToken(abortSignal);
        if (this.refreshProactively) {
            this.scheduleRefresh();
        }
    }
    async refreshToken(abortSignal) {
        try {
            if (!this.activeTokenFetching) {
                this.activeTokenFetching = this.refresh(abortSignal);
            }
            return parseToken(await this.activeTokenFetching);
        }
        finally {
            this.activeTokenFetching = null;
        }
    }
    scheduleRefresh() {
        if (this.disposed) {
            return;
        }
        if (this.activeTimeout) {
            clearTimeout(this.activeTimeout);
        }
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);
    }
    get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
    }
    get isCurrentTokenExpiringSoon() {
        return (!this.currentToken ||
            Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs);
    }
}
//# sourceMappingURL=autoRefreshTokenCredential.js.map