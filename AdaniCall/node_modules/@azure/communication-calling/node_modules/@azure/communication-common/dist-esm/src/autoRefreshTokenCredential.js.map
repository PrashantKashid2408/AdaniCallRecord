{"version":3,"file":"autoRefreshTokenCredential.js","sourceRoot":"","sources":["../../src/autoRefreshTokenCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignalLike, AccessToken } from \"@azure/core-http\";\nimport { parseToken } from \"./tokenParser\";\nimport { TokenCredential, CommunicationGetTokenOptions } from \"./communicationTokenCredential\";\n\n/**\n * Options for auto-refreshing a Communication Token credential.\n */\nexport interface CommunicationTokenRefreshOptions {\n  /**\n   * Function that returns a token acquired from the Communication configuration SDK.\n   */\n  tokenRefresher: (abortSignal?: AbortSignalLike) => Promise<string>;\n\n  /**\n   * Optional token to initialize.\n   */\n  token?: string;\n\n  /**\n   * Indicates whether the token should be proactively renewed prior to expiry or only renew on demand.\n   * By default false.\n   */\n  refreshProactively?: boolean;\n}\n\nconst expiredToken = { token: \"\", expiresOnTimestamp: -10 };\nconst minutesToMs = (minutes: number): number => minutes * 1000 * 60;\nconst defaultRefreshingInterval = minutesToMs(10);\n\nexport class AutoRefreshTokenCredential implements TokenCredential {\n  private readonly refresh: (abortSignal?: AbortSignalLike) => Promise<string>;\n  private readonly refreshProactively: boolean;\n  private readonly refreshingIntervalInMs: number = defaultRefreshingInterval;\n\n  private currentToken: AccessToken;\n  private activeTimeout: ReturnType<typeof setTimeout> | undefined;\n  private activeTokenFetching: Promise<string> | null = null;\n  private activeTokenUpdating: Promise<void> | null = null;\n  private disposed = false;\n\n  constructor(refreshArgs: CommunicationTokenRefreshOptions) {\n    const { tokenRefresher, token, refreshProactively } = refreshArgs;\n\n    this.refresh = tokenRefresher;\n    this.currentToken = token ? parseToken(token) : expiredToken;\n    this.refreshProactively = refreshProactively ?? false;\n\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  public async getToken(options?: CommunicationGetTokenOptions): Promise<AccessToken> {\n    if (!this.isCurrentTokenExpiringSoon) {\n      return this.currentToken;\n    }\n\n    const updatePromise = this.updateTokenAndReschedule(options?.abortSignal);\n\n    if (!this.isCurrentTokenValid) {\n      await updatePromise;\n    }\n\n    return this.currentToken;\n  }\n\n  public dispose(): void {\n    this.disposed = true;\n    this.activeTokenFetching = null;\n    this.activeTokenUpdating = null;\n    this.currentToken = expiredToken;\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n  }\n\n  private async updateTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    if (this.activeTokenUpdating) {\n      return this.activeTokenUpdating;\n    }\n    this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);\n    try {\n      await this.activeTokenUpdating;\n    } finally {\n      this.activeTokenUpdating = null;\n    }\n  }\n\n  private async refreshTokenAndReschedule(abortSignal?: AbortSignalLike): Promise<void> {\n    this.currentToken = await this.refreshToken(abortSignal);\n    if (this.refreshProactively) {\n      this.scheduleRefresh();\n    }\n  }\n\n  private async refreshToken(abortSignal?: AbortSignalLike): Promise<AccessToken> {\n    try {\n      if (!this.activeTokenFetching) {\n        this.activeTokenFetching = this.refresh(abortSignal);\n      }\n      return parseToken(await this.activeTokenFetching);\n    } finally {\n      this.activeTokenFetching = null;\n    }\n  }\n\n  private scheduleRefresh(): void {\n    if (this.disposed) {\n      return;\n    }\n    if (this.activeTimeout) {\n      clearTimeout(this.activeTimeout);\n    }\n    const timespanInMs =\n      this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;\n    this.activeTimeout = setTimeout(() => this.updateTokenAndReschedule(), timespanInMs);\n  }\n\n  private get isCurrentTokenValid(): boolean {\n    return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;\n  }\n\n  private get isCurrentTokenExpiringSoon(): boolean {\n    return (\n      !this.currentToken ||\n      Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs\n    );\n  }\n}\n"]}