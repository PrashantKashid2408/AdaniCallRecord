{"version":3,"file":"clientArguments.js","sourceRoot":"","sources":["../../../src/credential/clientArguments.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,iBAAiB,EAAkC,MAAM,kBAAkB,CAAC;AACrF,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAC9C,OAAO,EAAE,qBAAqB,EAAE,MAAM,oBAAoB,CAAC;AAE3D,MAAM,eAAe,GAAG,CAAC,IAAY,EAAW,EAAE;;IAChD,MAAM,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAEnC,OAAO,CACL,CAAC,CAAC,CAAA,MAAA,GAAG,CAAC,SAAS,EAAE,0CAAE,KAAK,CAAC,WAAW,CAAC,CAAA;QACrC,GAAG,CAAC,OAAO,EAAE,KAAK,SAAS;QAC3B,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE;QACpB,CAAC,GAAG,CAAC,OAAO,EAAE,KAAK,SAAS,IAAI,GAAG,CAAC,OAAO,EAAE,KAAK,EAAE,IAAI,GAAG,CAAC,OAAO,EAAE,KAAK,GAAG,CAAC,CAC/E,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,mBAAmB,GAAG,CAAC,IAAY,EAAQ,EAAE;IACjD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE;QAC1B,MAAM,IAAI,KAAK,CAAC,wBAAwB,IAAI,EAAE,CAAC,CAAC;KACjD;AACH,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,CAAC,MAAM,eAAe,GAAG,CAAC,UAAmB,EAA+B,EAAE;IAClF,MAAM,cAAc,GAAG,UAGtB,CAAC;IACF,OAAO,CACL,cAAc;QACd,OAAO,cAAc,CAAC,GAAG,KAAK,QAAQ;QACtC,cAAc,CAAC,QAAQ,KAAK,SAAS,CACtC,CAAC;AACJ,CAAC,CAAC;AAWF;;;GAGG;AACH,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,qBAA6B,EAC7B,mBAA6B,EACV,EAAE;IACrB,IAAI,eAAe,CAAC,mBAAmB,CAAC,IAAI,iBAAiB,CAAC,mBAAmB,CAAC,EAAE;QAClF,mBAAmB,CAAC,qBAAqB,CAAC,CAAC;QAC3C,OAAO,EAAE,GAAG,EAAE,qBAAqB,EAAE,UAAU,EAAE,mBAAmB,EAAE,CAAC;KACxE;SAAM;QACL,MAAM,EAAE,QAAQ,EAAE,IAAI,EAAE,UAAU,EAAE,GAAG,qBAAqB,CAAC,qBAAqB,CAAC,CAAC;QACpF,mBAAmB,CAAC,IAAI,CAAC,CAAC;QAC1B,OAAO,EAAE,GAAG,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC;KAClC;AACH,CAAC,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isTokenCredential, KeyCredential, TokenCredential } from \"@azure/core-auth\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport { parseConnectionString } from \"./connectionString\";\n\nconst isValidEndpoint = (host: string): boolean => {\n  const url = URLBuilder.parse(host);\n\n  return (\n    !!url.getScheme()?.match(/^http[s]?/) &&\n    url.getHost() !== undefined &&\n    url.getHost() !== \"\" &&\n    (url.getPath() === undefined || url.getPath() === \"\" || url.getPath() === \"/\")\n  );\n};\n\nconst assertValidEndpoint = (host: string): void => {\n  if (!isValidEndpoint(host)) {\n    throw new Error(`Invalid endpoint url ${host}`);\n  }\n};\n\n/**\n * Checks whether a value is a KeyCredential.\n *\n * @param credential - The credential being checked.\n */\nexport const isKeyCredential = (credential: unknown): credential is KeyCredential => {\n  const castCredential = credential as {\n    key: unknown;\n    getToken: unknown;\n  };\n  return (\n    castCredential &&\n    typeof castCredential.key === \"string\" &&\n    castCredential.getToken === undefined\n  );\n};\n\n/**\n * The URL and credential from parsing the arguments of a communication client.\n * @hidden\n */\nexport type UrlWithCredential = {\n  url: string;\n  credential: TokenCredential | KeyCredential;\n};\n\n/**\n * Parses arguments passed to a communication client.\n * @hidden\n */\nexport const parseClientArguments = (\n  connectionStringOrUrl: string,\n  credentialOrOptions?: unknown\n): UrlWithCredential => {\n  if (isKeyCredential(credentialOrOptions) || isTokenCredential(credentialOrOptions)) {\n    assertValidEndpoint(connectionStringOrUrl);\n    return { url: connectionStringOrUrl, credential: credentialOrOptions };\n  } else {\n    const { endpoint: host, credential } = parseConnectionString(connectionStringOrUrl);\n    assertValidEndpoint(host);\n    return { url: host, credential };\n  }\n};\n"]}